// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: encrypt.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct ServerRes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: ServerRes.OneOf_Content? = nil

  var resPq: ResPQ {
    get {
      if case .resPq(let v)? = content {return v}
      return ResPQ()
    }
    set {content = .resPq(newValue)}
  }

  var resDhparams: ResDHParams {
    get {
      if case .resDhparams(let v)? = content {return v}
      return ResDHParams()
    }
    set {content = .resDhparams(newValue)}
  }

  var resDhgenOk: ResDHGenOk {
    get {
      if case .resDhgenOk(let v)? = content {return v}
      return ResDHGenOk()
    }
    set {content = .resDhgenOk(newValue)}
  }

  var resDhgenRetry: ResDHGenRetry {
    get {
      if case .resDhgenRetry(let v)? = content {return v}
      return ResDHGenRetry()
    }
    set {content = .resDhgenRetry(newValue)}
  }

  var resDhgenFail: ResDHGenFail {
    get {
      if case .resDhgenFail(let v)? = content {return v}
      return ResDHGenFail()
    }
    set {content = .resDhgenFail(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case resPq(ResPQ)
    case resDhparams(ResDHParams)
    case resDhgenOk(ResDHGenOk)
    case resDhgenRetry(ResDHGenRetry)
    case resDhgenFail(ResDHGenFail)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .resPq: return {
        guard case .resPq(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .resDhparams: return {
        guard case .resDhparams(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .resDhgenOk: return {
        guard case .resDhgenOk(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .resDhgenRetry: return {
        guard case .resDhgenRetry(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .resDhgenFail: return {
        guard case .resDhgenFail(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: ServerRes.OneOf_Content, rhs: ServerRes.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resPq, .resPq): return {
        guard case .resPq(let l) = lhs, case .resPq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resDhparams, .resDhparams): return {
        guard case .resDhparams(let l) = lhs, case .resDhparams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resDhgenOk, .resDhgenOk): return {
        guard case .resDhgenOk(let l) = lhs, case .resDhgenOk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resDhgenRetry, .resDhgenRetry): return {
        guard case .resDhgenRetry(let l) = lhs, case .resDhgenRetry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resDhgenFail, .resDhgenFail): return {
        guard case .resDhgenFail(let l) = lhs, case .resDhgenFail(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ClientReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: ClientReq.OneOf_Content? = nil

  var reqPq: ReqPQ {
    get {
      if case .reqPq(let v)? = content {return v}
      return ReqPQ()
    }
    set {content = .reqPq(newValue)}
  }

  var reqDhparams: ReqDHParams {
    get {
      if case .reqDhparams(let v)? = content {return v}
      return ReqDHParams()
    }
    set {content = .reqDhparams(newValue)}
  }

  var reqClientDhparams: ReqClientDHParams {
    get {
      if case .reqClientDhparams(let v)? = content {return v}
      return ReqClientDHParams()
    }
    set {content = .reqClientDhparams(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case reqPq(ReqPQ)
    case reqDhparams(ReqDHParams)
    case reqClientDhparams(ReqClientDHParams)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .reqPq: return {
        guard case .reqPq(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .reqDhparams: return {
        guard case .reqDhparams(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .reqClientDhparams: return {
        guard case .reqClientDhparams(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: ClientReq.OneOf_Content, rhs: ClientReq.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reqPq, .reqPq): return {
        guard case .reqPq(let l) = lhs, case .reqPq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reqDhparams, .reqDhparams): return {
        guard case .reqDhparams(let l) = lhs, case .reqDhparams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reqClientDhparams, .reqClientDhparams): return {
        guard case .reqClientDhparams(let l) = lhs, case .reqClientDhparams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ReqPQ {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
}

struct ResPQ {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var pq: String {
    get {return _pq ?? String()}
    set {_pq = newValue}
  }
  /// Returns true if `pq` has been explicitly set.
  var hasPq: Bool {return self._pq != nil}
  /// Clears the value of `pq`. Subsequent reads from it will return its default value.
  mutating func clearPq() {self._pq = nil}

  var serverPublicKeyFingerprints: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _pq: String? = nil
}

struct PQInnerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pq: String {
    get {return _pq ?? String()}
    set {_pq = newValue}
  }
  /// Returns true if `pq` has been explicitly set.
  var hasPq: Bool {return self._pq != nil}
  /// Clears the value of `pq`. Subsequent reads from it will return its default value.
  mutating func clearPq() {self._pq = nil}

  var p: String {
    get {return _p ?? String()}
    set {_p = newValue}
  }
  /// Returns true if `p` has been explicitly set.
  var hasP: Bool {return self._p != nil}
  /// Clears the value of `p`. Subsequent reads from it will return its default value.
  mutating func clearP() {self._p = nil}

  var q: String {
    get {return _q ?? String()}
    set {_q = newValue}
  }
  /// Returns true if `q` has been explicitly set.
  var hasQ: Bool {return self._q != nil}
  /// Clears the value of `q`. Subsequent reads from it will return its default value.
  mutating func clearQ() {self._q = nil}

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var newNonce: Data {
    get {return _newNonce ?? Data()}
    set {_newNonce = newValue}
  }
  /// Returns true if `newNonce` has been explicitly set.
  var hasNewNonce: Bool {return self._newNonce != nil}
  /// Clears the value of `newNonce`. Subsequent reads from it will return its default value.
  mutating func clearNewNonce() {self._newNonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pq: String? = nil
  fileprivate var _p: String? = nil
  fileprivate var _q: String? = nil
  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _newNonce: Data? = nil
}

struct ReqDHParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var p: Data {
    get {return _p ?? Data()}
    set {_p = newValue}
  }
  /// Returns true if `p` has been explicitly set.
  var hasP: Bool {return self._p != nil}
  /// Clears the value of `p`. Subsequent reads from it will return its default value.
  mutating func clearP() {self._p = nil}

  var q: Data {
    get {return _q ?? Data()}
    set {_q = newValue}
  }
  /// Returns true if `q` has been explicitly set.
  var hasQ: Bool {return self._q != nil}
  /// Clears the value of `q`. Subsequent reads from it will return its default value.
  mutating func clearQ() {self._q = nil}

  var publicKeyFingerprint: String {
    get {return _publicKeyFingerprint ?? String()}
    set {_publicKeyFingerprint = newValue}
  }
  /// Returns true if `publicKeyFingerprint` has been explicitly set.
  var hasPublicKeyFingerprint: Bool {return self._publicKeyFingerprint != nil}
  /// Clears the value of `publicKeyFingerprint`. Subsequent reads from it will return its default value.
  mutating func clearPublicKeyFingerprint() {self._publicKeyFingerprint = nil}

  var encryptedData: Data {
    get {return _encryptedData ?? Data()}
    set {_encryptedData = newValue}
  }
  /// Returns true if `encryptedData` has been explicitly set.
  var hasEncryptedData: Bool {return self._encryptedData != nil}
  /// Clears the value of `encryptedData`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedData() {self._encryptedData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _p: Data? = nil
  fileprivate var _q: Data? = nil
  fileprivate var _publicKeyFingerprint: String? = nil
  fileprivate var _encryptedData: Data? = nil
}

struct EncryptedAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var g: Int32 {
    get {return _g ?? 0}
    set {_g = newValue}
  }
  /// Returns true if `g` has been explicitly set.
  var hasG: Bool {return self._g != nil}
  /// Clears the value of `g`. Subsequent reads from it will return its default value.
  mutating func clearG() {self._g = nil}

  var dhPrime: Data {
    get {return _dhPrime ?? Data()}
    set {_dhPrime = newValue}
  }
  /// Returns true if `dhPrime` has been explicitly set.
  var hasDhPrime: Bool {return self._dhPrime != nil}
  /// Clears the value of `dhPrime`. Subsequent reads from it will return its default value.
  mutating func clearDhPrime() {self._dhPrime = nil}

  var gA: Data {
    get {return _gA ?? Data()}
    set {_gA = newValue}
  }
  /// Returns true if `gA` has been explicitly set.
  var hasGA: Bool {return self._gA != nil}
  /// Clears the value of `gA`. Subsequent reads from it will return its default value.
  mutating func clearGA() {self._gA = nil}

  var serverTime: Int32 {
    get {return _serverTime ?? 0}
    set {_serverTime = newValue}
  }
  /// Returns true if `serverTime` has been explicitly set.
  var hasServerTime: Bool {return self._serverTime != nil}
  /// Clears the value of `serverTime`. Subsequent reads from it will return its default value.
  mutating func clearServerTime() {self._serverTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _g: Int32? = nil
  fileprivate var _dhPrime: Data? = nil
  fileprivate var _gA: Data? = nil
  fileprivate var _serverTime: Int32? = nil
}

struct ResDHParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var encryptedAnswer: Data {
    get {return _encryptedAnswer ?? Data()}
    set {_encryptedAnswer = newValue}
  }
  /// Returns true if `encryptedAnswer` has been explicitly set.
  var hasEncryptedAnswer: Bool {return self._encryptedAnswer != nil}
  /// Clears the value of `encryptedAnswer`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedAnswer() {self._encryptedAnswer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _encryptedAnswer: Data? = nil
}

struct ClientDHInnerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var retryID: Int32 {
    get {return _retryID ?? 0}
    set {_retryID = newValue}
  }
  /// Returns true if `retryID` has been explicitly set.
  var hasRetryID: Bool {return self._retryID != nil}
  /// Clears the value of `retryID`. Subsequent reads from it will return its default value.
  mutating func clearRetryID() {self._retryID = nil}

  var gB: Data {
    get {return _gB ?? Data()}
    set {_gB = newValue}
  }
  /// Returns true if `gB` has been explicitly set.
  var hasGB: Bool {return self._gB != nil}
  /// Clears the value of `gB`. Subsequent reads from it will return its default value.
  mutating func clearGB() {self._gB = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _retryID: Int32? = nil
  fileprivate var _gB: Data? = nil
}

struct ReqClientDHParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var encryptedData: Data {
    get {return _encryptedData ?? Data()}
    set {_encryptedData = newValue}
  }
  /// Returns true if `encryptedData` has been explicitly set.
  var hasEncryptedData: Bool {return self._encryptedData != nil}
  /// Clears the value of `encryptedData`. Subsequent reads from it will return its default value.
  mutating func clearEncryptedData() {self._encryptedData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _encryptedData: Data? = nil
}

struct ResDHGenOk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var newNonceHash1: Data {
    get {return _newNonceHash1 ?? Data()}
    set {_newNonceHash1 = newValue}
  }
  /// Returns true if `newNonceHash1` has been explicitly set.
  var hasNewNonceHash1: Bool {return self._newNonceHash1 != nil}
  /// Clears the value of `newNonceHash1`. Subsequent reads from it will return its default value.
  mutating func clearNewNonceHash1() {self._newNonceHash1 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _newNonceHash1: Data? = nil
}

struct ResDHGenRetry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var newNonceHash2: Data {
    get {return _newNonceHash2 ?? Data()}
    set {_newNonceHash2 = newValue}
  }
  /// Returns true if `newNonceHash2` has been explicitly set.
  var hasNewNonceHash2: Bool {return self._newNonceHash2 != nil}
  /// Clears the value of `newNonceHash2`. Subsequent reads from it will return its default value.
  mutating func clearNewNonceHash2() {self._newNonceHash2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _newNonceHash2: Data? = nil
}

struct ResDHGenFail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var serverNonce: Data {
    get {return _serverNonce ?? Data()}
    set {_serverNonce = newValue}
  }
  /// Returns true if `serverNonce` has been explicitly set.
  var hasServerNonce: Bool {return self._serverNonce != nil}
  /// Clears the value of `serverNonce`. Subsequent reads from it will return its default value.
  mutating func clearServerNonce() {self._serverNonce = nil}

  var newNonceHash3: Data {
    get {return _newNonceHash3 ?? Data()}
    set {_newNonceHash3 = newValue}
  }
  /// Returns true if `newNonceHash3` has been explicitly set.
  var hasNewNonceHash3: Bool {return self._newNonceHash3 != nil}
  /// Clears the value of `newNonceHash3`. Subsequent reads from it will return its default value.
  mutating func clearNewNonceHash3() {self._newNonceHash3 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonce: Data? = nil
  fileprivate var _serverNonce: Data? = nil
  fileprivate var _newNonceHash3: Data? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ServerRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ServerRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resPQ"),
    2: .same(proto: "resDHParams"),
    3: .same(proto: "resDHGenOk"),
    4: .same(proto: "resDHGenRetry"),
    5: .same(proto: "resDHGenFail"),
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ResPQ?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .resPq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .resPq(v)
        }
      }()
      case 2: try {
        var v: ResDHParams?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .resDhparams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .resDhparams(v)
        }
      }()
      case 3: try {
        var v: ResDHGenOk?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .resDhgenOk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .resDhgenOk(v)
        }
      }()
      case 4: try {
        var v: ResDHGenRetry?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .resDhgenRetry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .resDhgenRetry(v)
        }
      }()
      case 5: try {
        var v: ResDHGenFail?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .resDhgenFail(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .resDhgenFail(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .resPq?: try {
      guard case .resPq(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resDhparams?: try {
      guard case .resDhparams(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .resDhgenOk?: try {
      guard case .resDhgenOk(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .resDhgenRetry?: try {
      guard case .resDhgenRetry(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .resDhgenFail?: try {
      guard case .resDhgenFail(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ServerRes, rhs: ServerRes) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reqPQ"),
    2: .same(proto: "reqDHParams"),
    3: .same(proto: "reqClientDHParams"),
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: ReqPQ?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reqPq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reqPq(v)
        }
      }()
      case 2: try {
        var v: ReqDHParams?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reqDhparams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reqDhparams(v)
        }
      }()
      case 3: try {
        var v: ReqClientDHParams?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reqClientDhparams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reqClientDhparams(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .reqPq?: try {
      guard case .reqPq(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .reqDhparams?: try {
      guard case .reqDhparams(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .reqClientDhparams?: try {
      guard case .reqClientDhparams(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientReq, rhs: ClientReq) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReqPQ: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReqPQ"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReqPQ, rhs: ReqPQ) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResPQ: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResPQ"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .same(proto: "pq"),
    4: .standard(proto: "server_public_key_fingerprints"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._pq == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._pq) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.serverPublicKeyFingerprints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._pq {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.serverPublicKeyFingerprints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serverPublicKeyFingerprints, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResPQ, rhs: ResPQ) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._pq != rhs._pq {return false}
    if lhs.serverPublicKeyFingerprints != rhs.serverPublicKeyFingerprints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PQInnerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PQInnerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pq"),
    2: .same(proto: "p"),
    3: .same(proto: "q"),
    4: .same(proto: "nonce"),
    5: .standard(proto: "server_nonce"),
    6: .standard(proto: "new_nonce"),
  ]

  public var isInitialized: Bool {
    if self._pq == nil {return false}
    if self._p == nil {return false}
    if self._q == nil {return false}
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._newNonce == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._pq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._q) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._newNonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pq {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._q {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._newNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PQInnerData, rhs: PQInnerData) -> Bool {
    if lhs._pq != rhs._pq {return false}
    if lhs._p != rhs._p {return false}
    if lhs._q != rhs._q {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._newNonce != rhs._newNonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReqDHParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReqDHParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .same(proto: "p"),
    4: .same(proto: "q"),
    5: .standard(proto: "public_key_fingerprint"),
    6: .standard(proto: "encrypted_data"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._p == nil {return false}
    if self._q == nil {return false}
    if self._publicKeyFingerprint == nil {return false}
    if self._encryptedData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._p) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._q) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._publicKeyFingerprint) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._encryptedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._p {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._q {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._publicKeyFingerprint {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._encryptedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReqDHParams, rhs: ReqDHParams) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._p != rhs._p {return false}
    if lhs._q != rhs._q {return false}
    if lhs._publicKeyFingerprint != rhs._publicKeyFingerprint {return false}
    if lhs._encryptedData != rhs._encryptedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EncryptedAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EncryptedAnswer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .same(proto: "g"),
    4: .standard(proto: "dh_prime"),
    5: .standard(proto: "g_a"),
    6: .standard(proto: "server_time"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._g == nil {return false}
    if self._dhPrime == nil {return false}
    if self._gA == nil {return false}
    if self._serverTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._g) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._dhPrime) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._gA) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._serverTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._g {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._dhPrime {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._gA {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._serverTime {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EncryptedAnswer, rhs: EncryptedAnswer) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._g != rhs._g {return false}
    if lhs._dhPrime != rhs._dhPrime {return false}
    if lhs._gA != rhs._gA {return false}
    if lhs._serverTime != rhs._serverTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResDHParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResDHParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "encrypted_answer"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._encryptedAnswer == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._encryptedAnswer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._encryptedAnswer {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResDHParams, rhs: ResDHParams) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._encryptedAnswer != rhs._encryptedAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientDHInnerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientDHInnerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "retry_id"),
    4: .standard(proto: "g_b"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._retryID == nil {return false}
    if self._gB == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._retryID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._gB) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._retryID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._gB {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientDHInnerData, rhs: ClientDHInnerData) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._retryID != rhs._retryID {return false}
    if lhs._gB != rhs._gB {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReqClientDHParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReqClientDHParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "encrypted_data"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._encryptedData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._encryptedData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._encryptedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReqClientDHParams, rhs: ReqClientDHParams) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._encryptedData != rhs._encryptedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResDHGenOk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResDHGenOk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "new_nonce_hash1"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._newNonceHash1 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._newNonceHash1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._newNonceHash1 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResDHGenOk, rhs: ResDHGenOk) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._newNonceHash1 != rhs._newNonceHash1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResDHGenRetry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResDHGenRetry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "new_nonce_hash2"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._newNonceHash2 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._newNonceHash2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._newNonceHash2 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResDHGenRetry, rhs: ResDHGenRetry) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._newNonceHash2 != rhs._newNonceHash2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResDHGenFail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResDHGenFail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "server_nonce"),
    3: .standard(proto: "new_nonce_hash3"),
  ]

  public var isInitialized: Bool {
    if self._nonce == nil {return false}
    if self._serverNonce == nil {return false}
    if self._newNonceHash3 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serverNonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._newNonceHash3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._serverNonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._newNonceHash3 {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResDHGenFail, rhs: ResDHGenFail) -> Bool {
    if lhs._nonce != rhs._nonce {return false}
    if lhs._serverNonce != rhs._serverNonce {return false}
    if lhs._newNonceHash3 != rhs._newNonceHash3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
